# This code is auto-generated by xpdt; do not modify
# xpdt is written by Gianni Tedesco
# https://www.scaramanga.co.uk

# flake8: noqa: E501

#%- macro enumclass() -%#
$$namespace.python_enum_name$$
#%- endmacro -%#

#%- macro basetype() -%#
$$namespace.python_type_name$$
#%- endmacro %#

## import 'fixed.pyt' as x1b
## import 'vbuf.pyt' as x1v
from struct import Struct as _Struct
from pathlib import Path as _Path
from mmap import (
    mmap as _mmap,
    PROT_READ as _PROT_READ,
)
from typing import (
    NamedTuple as _NTup,
    Generator as _G,
    Callable as _F,
    Tuple as _Tup,
    Type as _Typ,
    TypeVar as _TV,
    Any as _Any,
    Optional as _O,
    Mapping as _M,
    Dict as _Dict,
)

__all__ = (
    '$$basetype()$$',
#% for struct in namespace %#
    '$$struct.name$$',
#% endfor %#
#% if namespace.has_name %#
    '$$enumclass()$$',
#% endif %#
)

_T = _TV('_T', bound='$$basetype()$$')

_vlen_fmt = _Struct('=I')
_vlen_size = _vlen_fmt.size
_vlen_unpack_from = _vlen_fmt.unpack_from
_vlen_pack = _vlen_fmt.pack

_enum_fmt = _Struct('=IIQ')
_enum_size = _enum_fmt.size
_enum_unpack_from = _enum_fmt.unpack_from
_enum_pack = _enum_fmt.pack


def _encode_intstack(field: _Tup[int, ...],
                     mask: int,
                     width: int,
                     ) -> int:
    val = 0
    for f in field:
        val <<= width
        val |= (f & mask)
    return val


def _decode_intstack(raw: int,
                     mask: int,
                     width: int,
                     ) -> _Tup[int, ...]:
    stk = []
    while raw:
        stk.append(raw & mask)
        raw >>= width
    return tuple(reversed(stk))


class $$basetype()$$:
    __slots__ = ()

    _unpack_from: _F[[memoryview, int], _Tup[int, ...]]
    _fmt_size: int
    _discr: _O[int] = None

    # These methods are defined in order to allow $$basetype()$$ class to be a
    # placeholder for any of the below classes. They should never be called
    # since the derived classes will provide their own implementations.
    @classmethod
    def __new__(cls: _Typ[_T], *args: _Any) -> _T:
        raise NotImplementedError

    # because we always mix in with namedtuple
    def _asdict(self) -> _Dict[str, _Any]:
        raise NotImplementedError

    def __bytes__(self) -> bytes:
        raise NotImplementedError

    @classmethod
    def _frombuf(cls: _Typ[_T],
                 buf: memoryview,
                 off: int = 0,
                 ) -> _T:
        raise NotImplementedError

    def _write(self) -> bytes:
        raise NotImplementedError

    @classmethod
    def _read(cls: _Typ[_T],
              buf: memoryview,
              off: int = 0,
              ) -> _T:
        raise NotImplementedError

    @classmethod
    def _read_many(cls: _Typ[_T],
                   buf: memoryview,
                   ) -> _G[_T, None, None]:
        raise NotImplementedError

    @classmethod
    def _from_file(cls: _Typ[_T],
                   p: _Path,
                   ) -> _G[_T, None, None]:
        raise NotImplementedError

    def _enum_wrap(self, ts: int) -> bytes:
        raise NotImplementedError

    def _len_wrap(self,
                  _p: _F[[int], bytes] = _vlen_pack,
                  ) -> bytes:
        buf = bytes(self)
        tot_len = _p(len(buf))
        return tot_len + buf

    @classmethod
    def _len_unwrap(cls: _Typ[_T],
                    buf: memoryview,
                    off: int = 0,
                    _unp: _F[[bytes, int], _Tup[int, ...]] = _vlen_unpack_from,
                    _hdr_len: int = _vlen_size,
                    ) -> _Tup[int, _T]:
        tot_len, = _unp(buf, off)
        off += _hdr_len
        end = off + tot_len
        payload = buf[off:end]
        return end, cls._frombuf(payload)
#% macro write_class(struct) %#


class _$$struct.name$$_tuple(_NTup):
#% for name, (type_name, type) in struct.non_reserved_members %#
    $$name$$: $$type.pytype$$
#% endfor %#


class $$struct.name$$(_$$struct.name$$_tuple, $$basetype()$$):
    __slots__ = ()

#% if struct.has_discriminant %#
    _discr = $$struct.discriminant$$
#% endif %#

    _fmt = _Struct('=$$struct.struct_fmt$$')
    _fmt_size = _fmt.size
    _pack = _fmt.pack
    _pack_into = _fmt.pack_into
    _unpack_from = _fmt.unpack_from
    _bin_size = _fmt.size
#% if struct.needs_vbuf %#
$$x1v.write_methods(struct)$$
#% elif not struct.all_members_scalar %#
$$x1b.write_methods(struct)$$
#% else %#

    def __bytes__(self,
                  _pk: _F[..., bytes] = _pack,
                  ) -> bytes:
        return _pk(*self)

    @classmethod
    def _frombuf(cls: _Typ[_T],
                 buf: memoryview,
                 off: int = 0,
                 _unp: _F[[bytes, int], _Tup[int, ...]] = _unpack_from,
                 ) -> _T:
        return cls(*_unp(buf, off))

    _write = __bytes__
    _read = _frombuf

    @classmethod
    def _read_many(cls: _Typ[_T],
                   buf: memoryview,
                   rec_len: int = _fmt_size,
                   unpack: _F[[bytes, int], _Tup[int, ...]] = _unpack_from,
                   ) -> _G[_T, None, None]:
        off = 0
        tot_len = len(buf)
        while off < tot_len:
            yield cls(*cls._unpack_from(buf, off))
            off += cls._fmt_size

    @classmethod
    def _from_file(cls: _Typ[_T],
                   p: _Path,
                   ) -> _G[_T, None, None]:
        with p.open('rb') as f:
            content = _mmap(f.fileno(), 0, access=_PROT_READ)
            yield from cls._read_many(memoryview(content))
#% endif %#

#% if struct.has_discriminant %#
    def _enum_wrap(self,
                   ts: int,
                   _p: _F[[int, int, int], bytes] = _enum_pack,
                   _d: int = _discr,
                   ) -> bytes:
        buf = bytes(self)
        tot_len = _p(len(buf), _d, ts)
        return tot_len + buf
#% endif %#

    @classmethod
    def _frombytes(cls: _Typ[_T],
                   buf: bytes,
                   _frombuf: _F[[_Typ[_T], memoryview, int], _T] = (
                       getattr(_frombuf, '__func__')
                   )) -> _T:
        return _frombuf(cls, memoryview(buf), 0)
#%- endmacro -%#

#%- for struct in namespace -%#
$$write_class(struct)$$
#% endfor %#
#%- if namespace.has_name %#


class $$enumclass()$$:
    __slots__ = ()

    struct_names = frozenset({
#% for struct in namespace %#
        '$$struct.name$$',
#% endfor %#
    })

    structs: _M[int, _Typ[$$basetype()$$]] = {
#% for struct in namespace %#
#% if struct.has_discriminant %#
        $$struct.discriminant$$: $$struct.name$$,
#% endif %#
#% endfor %#
    }

    @classmethod
    def read_many(cls,
                  buf: memoryview,
                  _unp: _F[[bytes, int], _Tup[int, ...]] = _enum_unpack_from,
                  _hdr_len: int = _enum_size,
                  _clsmap: _M[int, _Typ[$$basetype()$$]] = structs,
                  ) -> _G[_Tup[int, $$basetype()$$], None, None]:
        tot_len = len(buf)
        off = 0
        while off < tot_len:
            rec_len, discr, ts = _unp(buf, off)
            off += _hdr_len
            t = _clsmap[discr]
            yield ts, t._frombuf(buf, off)
            off += rec_len

    @classmethod
    def from_file(cls,
                  p: _Path,
                  ) -> _G[_Tup[int, $$basetype()$$], None, None]:
        with p.open('rb') as f:
            try:
                content = _mmap(f.fileno(), 0, access=_PROT_READ)
            except ValueError:
                return
            yield from cls.read_many(memoryview(content))
#% endif %#
